package mystudy.lang.literal;

// # 정수 리터럴 - 메모리에 저장하는 방법
// 값을 메모리에 저장하려면 2진수로 표현할 수 있어야 한다.

public class Test05 {
    public static void main(String[] args) {
        System.out.println(5 - 3);
        System.out.println(5 + (-3));
    }
}

// ## 정수를 2진수로 표현하는 방법
// 1) 부호-크기/절대값(Sign-Magnitude)
// - 부동 소수점에서 가수부(significand or mantissa)를 저장할 때 사용.

// 2) 1의 보수(One's Complement)
// - 모든 비트를 반대 값으로 바꾼다.

// 3) 2의 보수(Two's complement)
// - 자바에서 음수를 저아하는 방법이다.
// - 1의 보수의 문제점을 해결하기 위해 등장한 방법.
// - 음수 0을 없앰으로써 -128까지 표현할 수 있음.
// - 2의 보수를 만드는 방법 1:
// - 모든 비트를 반대 값으로 만든 다음 1을 더한다.
// - 2의 보수를 만드는 방법 2:
// - 오른쪽에서부터 1을 찾는다.
// - 찾은 1의 왼쪽편에 있는 모든 비트를 반대 값으로 바꾼다.
// - 2의 보수를 만드는 방법 3:
// - 2^n(8비트일 경우 2^8 = 256)에서 음수 값 만큼 뺀다.

// 4) K-초과(Excess-K)
// - 부동 소수점의 지수부(exponent)를 저장할 때 사용한다.
// - 오프셋 바이너리(offset binary) 또는 바이어스된 표기법(biased representation) 이라고도 한다.
// - K를 바이어스 값이라 부르며, 표현하려는 값에 더할 때 사용한다.
// 표현하려는 값 + 초과 값(K) = 결과
// - 바이어스 값(K)을 구하는 공식:
// K = 2^(비트수 - 1)
// 예) 8비트일 경우 ---> K = 2^(8 - 1) = 2^7 = 128, 결과 = 128 + 값
// 1111 1111 = 128 + 127
// 1111 1110 = 128 + 126
// 1111 1101 = 128 + 125
// ...
// 1000 0001 = 128 + 1
// 1000 0000 = 128 + 0
// 0111 1111 = 128 + (-1)
// ...
// 0000 0010 = 128 + (-126)
// 0000 0001 = 128 + (-127)
// 0000 0000 = 128 + (-128)
//
// - IEEE 부동소수점 표준에서는 다음의 공식을 사용한다.
// K = 2^(비트수 - 1) - 1
// 예) 8비트일 경우 ---> K = 2^7 - 1 = 127, 결과 = 127 + 값
// 1111 1111 = 127 + 128
// 1111 1110 = 127 + 127
// 1111 1101 = 127 + 126
// 1111 1100 = 127 + 125
// ...
// 1000 0000 = 127 + 1
// 0111 1111 = 127 + 0
// 0111 1110 = 127 + (-1)
// ...
// 0000 0010 = 127 + (-125)
// 0000 0001 = 127 + (-126)
// 0000 0000 = 127 + (-127)
//
// - 바이어스 방식으로 데이터를 저장할 때의 이점?
// - 모든 비트가 0일 때 최소 값을 가지고, 모든 비트가 1일 때 최대 값을 갖는다.
// - 이런 이유로 작은 값에서 큰 값으로 정렬되는 결과를 낳는다.
// - 모든 비트가 정렬된 상태이기 때문에 부동소수점이든 정수이든 상관없이 값을 비교할 때 속도가 빠르다.
// - '부호-크기', '1의 보수', '2의 보수'와 같은 방법으로 값을 표현할 경우, 비트들이 순차적으로 정렬되지 않는다.
//